package models

import (
	"errors"

	"github.com/graveslug/unassuming-photo-gallery/hash"
	"github.com/graveslug/unassuming-photo-gallery/rand"

	"github.com/jinzhu/gorm"
	//I don't want to defend why I'm doing this. :(
	_ "github.com/jinzhu/gorm/dialects/postgres"
	"golang.org/x/crypto/bcrypt"
)

var (
	//ErrNotFound makes an apperance when a resource cannot be found in the database. You can keep trying to find it though if you'd like.
	ErrNotFound = errors.New("models: resource not found")
	//ErrInvalidID is returned when an invalid ID is provided to a method like Delete.
	ErrInvalidID = errors.New("models: ID provided was invalid")
	//ErrInvalidPassword is returned when invalid password is used when attempting to authenticate the user
	ErrInvalidPassword = errors.New("models: incorrect password provided")

	userPwPepper = "Don'tGetExcitedThisWillChangeAndThereIsNoCloud"
)

//UserDB is used to ineract with the users database
//For pretty much all single user queries:
//If the user is found, we will return a nil error
//If the user is not found, we will return ErrNotFound
//If there is another error, we will return an error with more information about what went wrong. This may not be an error generated by the models package.
//For single user queries, any err but ErrNotFound should probaly result in a 500 error until we make "public" facing errors
type UserDB interface {
	//Methods for querying for single users
	ById(id uint) (*User, error)
	ByEmail(email string) (*User, error)
	ByRemember(token string) (*User, error)

	//Methods for altering users
	Create(user *User) error
	Update(user *User) error
	Delete(id uint) error

	//Used to close a DB connection
	Close() error

	//Migration helpers
	AutoMigrate() error
	DestructiveReset() error
}

//User model
type User struct {
	gorm.Model
	Name         string
	Email        string `gorm:"not null;unique_index"`
	Password     string `gorm:"-"`
	PasswordHash string `gorm:"not null"`
	Remember     string `gorm:"-"`
	RememberHash string `gorm:"not null; unique_index"`
}

//UserService provides methods for querying, creating, and updating the users.
type UserService struct {
	db   *gorm.DB
	hmac hash.HMAC
}

const hmacSecretKey = "thisWillChangeToo"

//NewUserService opens a connection to the database.
func NewUserService(connectionInfo string) (*UserService, error) {
	db, err := gorm.Open("postgres", connectionInfo)
	if err != nil {
		return nil, err
	}
	db.LogMode(true)
	hmac := hash.NewHMAC(hmacSecretKey)
	return &UserService{
		db:   db,
		hmac: hmac,
	}, nil
}

// Close the UserService database connection.
func (us *UserService) Close() error {
	return us.db.Close()
}

//ByID will look up the user with the provided ID.
//if user found returns the user if not returns the error
func (us *UserService) ByID(id uint) (*User, error) {
	var user User
	db := us.db.Where("id = ?", id)
	err := first(db, &user)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

//DestructiveReset drops the user table and rebuilds it. Not for production build
func (us *UserService) DestructiveReset() error {
	err := us.db.DropTableIfExists(&User{}).Error
	if err != nil {
		return err
	}
	return us.AutoMigrate()
}

//Create will create the user and backfill data like the ID createdAt and updatedAt fields
func (us *UserService) Create(user *User) error {
	pwBytes := []byte(user.Password + userPwPepper)
	hashedBytes, err := bcrypt.GenerateFromPassword(
		pwBytes, bcrypt.DefaultCost)
	if err != nil {
		return err
	}
	user.PasswordHash = string(hashedBytes)
	user.Password = ""
	if user.Remember == "" {
		token, err := rand.RememberToken()
		if err != nil {
			return err
		}
		user.Remember = token
	}
	user.RememberHash = us.hmac.Hash(user.Remember)
	return us.db.Create(user).Error
}

//first will query using the gorm.DB and it will get thef irst item returned and place it into the dst. If nothing is found in the query it will return ErrNotFound
func first(db *gorm.DB, dst interface{}) error {
	err := db.First(dst).Error
	if err == gorm.ErrRecordNotFound {
		return ErrNotFound
	}
	return err
}

//ByEmail finding the user by email search
func (us *UserService) ByEmail(email string) (*User, error) {
	var user User
	db := us.db.Where("email = ?", email)
	err := first(db, &user)
	return &user, err
}

//Update updates the user
func (us *UserService) Update(user *User) error {
	if user.Remember != "" {
		user.RememberHash = us.hmac.Hash(user.Remember)
	}
	return us.db.Save(user).Error
}

//Delete the user. BUT the thing with Gorm is that if we provide a id of zero to Gorm-Gorm will delete all our users. To prevent this we wrote an error variable and set an if statement to zero.
func (us *UserService) Delete(id uint) error {
	if id == 0 {
		return ErrInvalidID
	}
	user := User{Model: gorm.Model{ID: id}}
	return us.db.Delete(&user).Error
}

//AutoMigrate will attempt to automatically migrate the users table
func (us *UserService) AutoMigrate() error {
	if err := us.db.AutoMigrate(&User{}).Error; err != nil {
		return err
	}
	return nil
}

//Authenticate can be used to authenticate a suer with the provided email address and password
//if the email address provided is invalid, this will return
//nil, ErrNotFound
//If password provided is invalid, this will return
//nil, errInvalidPassword
//if the email and password are both valid this will return
//user, nil
//otherwise if another error is encountered this will return
//nil, error
func (us *UserService) Authenticate(email, password string) (*User, error) {
	foundUser, err := us.ByEmail(email)
	if err != nil {
		return nil, err
	}
	err = bcrypt.CompareHashAndPassword(
		[]byte(foundUser.PasswordHash),
		[]byte(password+userPwPepper))
	switch err {
	case nil:
		return foundUser, nil
	case bcrypt.ErrMismatchedHashAndPassword:
		return nil, ErrInvalidPassword
	default:
		return nil, err
	}
}

//ByRemember looks up a user with a given rememberToken
//and rreturns that user. This method will handle hashing the token for us.
func (us *UserService) ByRemember(token string) (*User, error) {
	var user User
	rememberHash := us.hmac.Hash(token)
	err := first(us.db.Where("remember_hash = ?", rememberHash), &user)
	if err != nil {
		return nil, err
	}
	return &user, nil
}
